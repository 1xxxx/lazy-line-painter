/*
 * Lazy Line Painter
 * SVG Stroke animation.
 *
 * https://github.com/camoconnell/lazy-line-painter
 * http://www.camoconnell.com
 *
 * Licensed under the MIT license.
 *
 */
(function(e, r, t) {
    var k = {
            init: function(b) {
                return this.each(function() {
                    var a = e(this),
                        c = a.data("lazyLinePainter");
                    a.addClass("lazy-line");
                    if (!c) {
                        var c = e.extend({
                                width: null,
                                height: null,
                                strokeWidth: 2,
                                strokeColor: "#000",
                                strokeOverColor: null,
                                strokeCap: "round",
                                strokeJoin: "round",
                                strokeOpacity: 1,
                                arrowEnd: "none",
                                strokeDash: null,
                                onComplete: null,
                                delay: null,
                                overrideKey: null,
                                drawSequential: !0,
                                speedMultiplier: 1
                            }, b),
                            d = c.overrideKey ? c.overrideKey : a.attr("id").replace("#", ""),
                            f = c.svgData[d].dimensions.width,
                            l = c.svgData[d].dimensions.height;
                        c.svgData = c.svgData[d].strokepath;
                        null === c.width && (c.width = f);
                        null === c.height && (c.height = l);
                        d = "0 0 " + f + " " + l;
                        f = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                        f.setAttributeNS(null, "viewBox", d);
                        f.setAttributeNS(null, "preserveAspectRatio", "xMidYMid");
                        f.setAttribute("xmlns", "http://www.w3.org/2000/svg");
                        c.svg = e(f);
                        a.append(c.svg);
                        a.data("lazyLinePainter", c)
                    }
                })
            },
            paint: function() {
                return this.each(function() {
                    var b = e(this),
                        a = b.data("lazyLinePainter"),
                        c = function() {
                            b.css({
                                width: a.width,
                                height: a.height
                            });
                            a.paths = [];
                            a.longestDuration = 0;
                            for (var c = a.playhead = 0; c < a.svgData.length; c++) {
                                var f = m(a, c),
                                    e = Math.ceil(f.getTotalLength());
                                f.style.strokeDasharray = e + " " + e;
                                f.style.strokeDashoffset = e;
                                f.style.display = "block";
                                f.getBoundingClientRect();
                                var g = a.svgData[c].duration * a.speedMultiplier;
                                g > a.longestDuration && (a.longestDuration = g);
                                a.paths.push({
                                    duration: g,
                                    drawStartTime: a.playhead,
                                    path: f,
                                    length: e
                                });
                                a.playhead += g
                            }
                            a.totalDuration = a.drawSequential ? a.playhead : a.longestDuration;
                            a.rAF = requestAnimationFrame(function(b) {
                                h(b,
                                    a)
                            })
                        };
                    null === a.delay ? c() : setTimeout(c, a.delay)
                })
            },
            pauseResume: function() {
                return this.each(function() {
                    var b = e(this).data("lazyLinePainter");
                    b.paused ? (b.paused = !1, requestAnimationFrame(function(a) {
                        n(a, b)
                    })) : (b.paused = !0, cancelAnimationFrame(b.rAF))
                })
            },
            erase: function() {
                return this.each(function() {
                    var b = e(this);
                    b.removeData("lazyLinePainter");
                    b.find("svg").empty()
                })
            },
            destroy: function() {
                return this.each(function() {
                    var b = e(this);
                    b.removeData("lazyLinePainter");
                    b.remove()
                })
            },
            stamp: function() {
                return this.each(function() {
                    var b =
                        e(this),
                        a = b.data("lazyLinePainter"),
                        c = function() {
                            b.css({
                                width: a.width,
                                height: a.height
                            });
                            for (i = 0; i < a.svgData.length; i++) a.paper.path(a.svgData[i].path).attr(p(a, a.svgData[i]))
                        };
                    null === a.delay ? c() : setTimeout(c, a.delay)
                })
            }
        },
        n = function(b, a) {
            a.startTime = b - a.elapsed_time;
            requestAnimationFrame(function(b) {
                h(b, a)
            })
        },
        h = function(b, a) {
            null == a.startTime && (a.startTime = b);
            a.elapsed_time = b - a.startTime;
            for (var c = 0; c < a.paths.length; c++) {
                var d;
                a.drawSequential ? (d = a.elapsed_time - a.paths[c].drawStartTime, 0 > d && (d = 0)) :
                    d = a.elapsed_time;
                d < a.paths[c].duration && 0 < d ? a.paths[c].path.style.strokeDashoffset = a.paths[c].length - d / a.paths[c].duration * a.paths[c].length : d > a.paths[c].duration && (a.paths[c].path.style.strokeDashoffset = 0)
            }
            if (a.elapsed_time < a.totalDuration) a.rAF = requestAnimationFrame(function(b) {
                h(b, a)
            });
            else if (null != a.onComplete) a.onComplete()
        },
        p = function(b, a) {
            return {
                stroke: a.strokeColor ? a.strokeColor : b.strokeColor,
                "fill-opacity": 0,
                "stroke-dasharray": a.strokeDash ? a.strokeDash : b.strokeDash,
                "stroke-opacity": a.strokeOpacity ?
                    a.strokeOpacity : b.strokeOpacity,
                "stroke-width": a.strokeWidth ? a.strokeWidth : b.strokeWidth,
                "stroke-linecap": a.strokeCap ? a.strokeCap : b.strokeCap,
                "stroke-linejoin": a.strokeJoin ? a.strokeJoin : b.strokeJoin
            }
        },
        m = function(b, a) {
            var c = document.createElementNS("http://www.w3.org/2000/svg", "path"),
                d = e(c);
            b.svg.append(d);
            d.attr(q(b, b.svgData[a]));
            return c
        },
        q = function(b, a) {
            return {
                d: a.path,
                stroke: a.strokeColor ? a.strokeColor : b.strokeColor,
                "fill-opacity": 0,
                "stroke-dasharray": a.strokeDash ? a.strokeDash : b.strokeDash,
                "stroke-opacity": a.strokeOpacity ?
                    a.strokeOpacity : b.strokeOpacity,
                "stroke-width": a.strokeWidth ? a.strokeWidth : b.strokeWidth,
                "stroke-linecap": a.strokeCap ? a.strokeCap : b.strokeCap,
                "stroke-linejoin": a.strokeJoin ? a.strokeJoin : b.strokeJoin,
                "arrow-end": a.arrowEnd ? a.arrowEnd : b.arrowEnd,
                markerWidth: "4",
                markerHeight: "3",
                orient: "auto"
            }
        };
    e.fn.lazylinepainter = function(b) {
        if (k[b]) return k[b].apply(this, Array.prototype.slice.call(arguments, 1));
        if ("object" === typeof b || !b) return k.init.apply(this, arguments)
    }
})(jQuery, window);